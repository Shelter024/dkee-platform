import { NextRequest } from 'next/server';
import fs from 'fs';
import path from 'path';
import { spawn } from 'child_process';

export const runtime = 'nodejs';

interface ApplyBody {
  action: 'apply';
  databaseUrl: string;
  nextAuthSecret: string;
  encryptionKey: string;
  adminEmail: string;
  adminPassword: string;
  adminName: string;
}

interface TestDbBody {
  action: 'test-db';
  databaseUrl: string;
}

function runCommand(cmd: string, args: string[], env: Record<string, string>): Promise<{ code: number; stdout: string; stderr: string; }> {
  return new Promise((resolve) => {
    const isWin = process.platform === 'win32';
    const child = spawn(cmd, args, {
      env: { ...process.env, ...env },
      cwd: process.cwd(),
      shell: isWin, // Use shell on Windows for .cmd files
    });
    let stdout = '';
    let stderr = '';
    child.stdout?.on('data', (d) => (stdout += d.toString()));
    child.stderr?.on('data', (d) => (stderr += d.toString()));
    child.on('close', (code) => resolve({ code: code ?? 0, stdout, stderr }));
    child.on('error', (err) => resolve({ code: 1, stdout: '', stderr: err.message }));
  });
}

export async function POST(req: NextRequest) {
  const body = await req.json();
  const action = body.action as string;

  if (action === 'test-db') {
    const { databaseUrl } = body as TestDbBody;
    if (!databaseUrl) {
      return Response.json({ ok: false, error: 'DATABASE_URL missing' }, { status: 400 });
    }
    // Attempt a lightweight connection using a temporary PrismaClient
    try {
      const { PrismaClient } = await import('@prisma/client');
      const prisma = new PrismaClient({ datasources: { db: { url: databaseUrl } } });
      await prisma.$queryRaw`SELECT 1`;
      await prisma.$disconnect();
      return Response.json({ ok: true });
    } catch (e: any) {
      return Response.json({ ok: false, error: e.message });
    }
  }

  if (action === 'apply') {
    const { databaseUrl, nextAuthSecret, encryptionKey, adminEmail, adminPassword, adminName } = body as ApplyBody;
    const missing = [
      ['databaseUrl', databaseUrl],
      ['nextAuthSecret', nextAuthSecret],
      ['encryptionKey', encryptionKey],
      ['adminEmail', adminEmail],
      ['adminPassword', adminPassword],
      ['adminName', adminName],
    ].filter(([, v]) => !v);
    if (missing.length) {
      return Response.json({ ok: false, error: 'Missing fields', fields: missing.map(m => m[0]) }, { status: 400 });
    }

    const envLines: string[] = [
      '# Auto-generated by setup wizard',
      `DATABASE_URL=${databaseUrl}`,
      `NEXTAUTH_SECRET=${nextAuthSecret}`,
      `SETTINGS_ENCRYPTION_KEY=${encryptionKey}`,
      'NODE_ENV=development',
      'NEXTAUTH_URL=http://localhost:3000',
      'NEXT_PUBLIC_APP_URL=http://localhost:3000',
      'NEXT_PUBLIC_BASE_URL=http://localhost:3000',
      '# Placeholders for later configuration via settings UI',
      'CLOUDINARY_CLOUD_NAME=',
      'CLOUDINARY_API_KEY=',
      'CLOUDINARY_API_SECRET=',
      'PUSHER_APP_ID=',
      'PUSHER_SECRET=',
      'PUSHER_CLUSTER=eu',
      'NEXT_PUBLIC_PUSHER_APP_KEY=',
      'TWILIO_ACCOUNT_SID=',
      'TWILIO_AUTH_TOKEN=',
      'TWILIO_PHONE_NUMBER=',
    ];
    try {
      const envPath = path.join(process.cwd(), '.env');
      fs.writeFileSync(envPath, envLines.join('\n') + '\n', 'utf8');
    } catch (e: any) {
      return Response.json({ ok: false, error: `Failed writing .env: ${e.message}` }, { status: 500 });
    }

    // Run prisma db push
    const dbPush = await runCommand('npx', ['prisma', 'db', 'push', '--accept-data-loss'], { DATABASE_URL: databaseUrl });
    if (dbPush.code !== 0) {
      return Response.json({ ok: false, step: 'db-push', error: 'Database migration failed', details: dbPush.stderr || dbPush.stdout }, { status: 500 });
    }

    // Run seed with minimal mode
    const seed = await runCommand('npx', ['prisma', 'db', 'seed'], {
      DATABASE_URL: databaseUrl,
      MINIMAL_SEED: 'true',
      ADMIN_EMAIL: adminEmail,
      ADMIN_PASSWORD: adminPassword,
      ADMIN_NAME: adminName,
    });
    if (seed.code !== 0) {
      return Response.json({ ok: false, step: 'seed', error: 'Database seeding failed', details: seed.stderr || seed.stdout }, { status: 500 });
    }

    return Response.json({ ok: true, message: 'Setup completed successfully!' });
  }

  return Response.json({ ok: false, error: 'Unsupported action' }, { status: 400 });
}

export async function GET() {
  // Basic status: check if .env exists & database seems migrated (Settings table?)
  const envExists = fs.existsSync(path.join(process.cwd(), '.env'));
  let dbReady = false;
  if (envExists) {
    try {
      const { PrismaClient } = await import('@prisma/client');
      const prisma = new PrismaClient();
      await prisma.setting.count().then(() => (dbReady = true)).catch(() => {});
      await prisma.$disconnect();
    } catch (_) {
      dbReady = false;
    }
  }
  return Response.json({ ok: true, envExists, dbReady });
}
